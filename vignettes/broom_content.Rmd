## Question 1

First, let's load the required packages and data
```{r, message = FALSE}
library(broom)
library(tidyverse)
library(jrTidyverse2)
data(beer, package = "jrTidyverse2")
```
This data contains roughly 1500 beers, their alcohol percentage and their colour. Colour is ranked from 1-50, with 50 being the highest.      

1) Use `?beer` and `head(beer)` to get a brief overview of the data. 

2) We are going to look at how the colour of a beer affects the alcohol 
percentage using linear regression. 
```{r}
fit = lm(ABV ~ Color, data = beer)
```
The above code will run a linear regression model with alcohol percentage, `ABV`, as the response and colour, `Color`, as a variable. Explore the output of `summary(fit)`. Can you grab the p-values?     
Hint: use `summary(fit)$coefficients[,4]`
```{r, echo = FALSE}
summary(fit)$coefficients[,4]
```

3) That method of grabbing the p-values was tiresome wasn't it? Tidy and store the output of `fit()` such that it is easier to grab the p-values.     
Hint: use `tidy()`
```{r, echo = FALSE}
tidy_fit = tidy(fit)
tidy_fit$p.value
```

4) Using the **GGally** package, produce a coefficient plot.
```{r, echo = FALSE, message = FALSE}
library("GGally")
ggcoef(fit, exclude_intercept = TRUE,
errorbar_height = 0.5, vline_color = "red")
```

5) Now we are interested in visualising how well the model has performed. We can do this using the fitted values. Store the data along side the fitted values from the model.      
Hint: use `augment()`
```{r, echo = FALSE}
aug_fit = augment(fit)
```

6) Amend the code in the notes given to make Figure 1.3 to plot the fitted values against the original data. Alternatively you can use base R to perform this task by using `plot()` and `points()`. Does it look like the model has performed adequately? 
```{r, echo = FALSE}
aug_fit %>% 
  select(ABV, Color, .fitted) %>% 
  gather(Type, Value, -Color) %>% 
  ggplot(aes(x = Color)) + 
  geom_point(aes(y = Value, colour = Type))

## OR

plot(aug_fit$Color, aug_fit$ABV)
points(aug_fit$Color, aug_fit$.fitted, col = "red", type = "l")
```


7) Grab the adjusted r squared for the model.    
Hint: use `glance()`

8) Adjusted R squared is a measure of how well the model is explaining the variation in the data. It is basically a measure of how close all of the original points are to the fitted values. This value can be anything between 0-1. 0 would mean the model explains no variation and therefore is not very good whilst 1 would be the model explains all of the variation and therefore is very good. How good is the model at explaining the variation in the data?

## Question 2 

The functions within **broom** can be used on the outputs of lots  of statistical functions in R, not just linear regression. To get a full list of the functions **broom** works on, go to the **broom** GitHub page and scroll to the bottom.

> https://github.com/tidyverse/broom

To demonstrate this, we're going to look at another type of statistical inference, a t-test. The command for a t-test in R is `t.test()`. 
```{r}
data(movies, package = "ggplot2movies")
test = t.test(budget ~ Action, data = movies)
```
Here we are performing what is called a "two-sample" t-test where we are asking if the budget is the same for each category in `Action`. Basically, we are testing if the average budget is the same for non-action and action movies. 

1) Explore the output of the this t-test *without* using **broom**.
```{r, echo = FALSE}
test
```

2) Now explore the output of the t-test using **broom**. Why do you think `augment()` doesn't work for t-tests?
```{r}
tidy(test)
glance(test)

# Augment doesn't work on t-tests as there is no meaningful sense in which a hypothesis test produces output about each initial data point.
```

2) At the bottom of the print output for the t-test, it will give you the mean budget for each category in `Action`. Can you get these using **dplyr**?
Hint: Use `group_by()` then `summarise()`
```{r}
movies %>% 
  group_by(Action) %>% 
  summarise(mean(budget, na.rm = TRUE))
```
